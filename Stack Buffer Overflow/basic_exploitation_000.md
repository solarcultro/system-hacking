# [basic_exploitation_000](https://dreamhack.io/wargame/challenges/2/) 

 문제 파일의 코드는 다음과 같다. 주석은 코드의 해석들 위하여 본인이 직접 작성한 것이다.

```C
#include <stdio.h>
#include <stdlib.h>
#include <signal.h>
#include <unistd.h>


void alarm_handler() {
    puts("TIME OUT");
    exit(-1);
}


void initialize() {
    setvbuf(stdin, NULL, _IONBF, 0); // 표준 입력에서 버퍼를 사용하지 않는다.버퍼를 지나지 않고 요청 즉시 작업이 진행된다. 
    setvbuf(stdout, NULL, _IONBF, 0); // 표준 출력에서 버퍼를 사용하지 않는다. 버퍼를 지나지 않고 요청 즉시 작업이 진행된다.

    signal(SIGALRM, alarm_handler); // SIGALRM이 발생하면 alarm_handler를 실행한다.
    alarm(30);//30초 후에 SIGALRM을 발생시킴.
}


int main(int argc, char *argv[]) {

    char buf[0x80];

    initialize();
    
    printf("buf = (%p)\n", buf);
    scanf("%141s", buf);

    return 0;
}
```

## Exploit strategy
 유심히 봐야할 코드는 scanf("%141s", buf); 이다. buf의 크기는 0x80 = 128 byte이므로 scanf를 통하여 buf의 크기보다 더 많은 양의 데이터를 입력할 수 있다. 이를 이용하여 스택 버퍼 오버 플로우를 발생시키면 된다. pwndbg를 통하여 주어진 바이너리 파일의 main함수를 disassemble하여 살펴보자. 
 
```assembly 
   0x080485d9 <+0>:     push   ebp
   0x080485da <+1>:     mov    ebp,esp
   0x080485dc <+3>:     add    esp,0xffffff80
   0x080485df <+6>:     call   0x8048592 <initialize>
   0x080485e4 <+11>:    lea    eax,[ebp-0x80]
   0x080485e7 <+14>:    push   eax
   0x080485e8 <+15>:    push   0x8048699
   0x080485ed <+20>:    call   0x80483f0 <printf@plt>
   0x080485f2 <+25>:    add    esp,0x8
   0x080485f5 <+28>:    lea    eax,[ebp-0x80] // 오버플로우를 발생시킬 버퍼는 ebp-0x80에 위치함. 
   0x080485f8 <+31>:    push   eax
   0x080485f9 <+32>:    push   0x80486a5
   0x080485fe <+37>:    call   0x8048460 <__isoc99_scanf@plt>
   0x08048603 <+42>:    add    esp,0x8
   0x08048606 <+45>:    mov    eax,0x0
   0x0804860b <+50>:    leave
   0x0804860c <+51>:    ret
```

lea eax,[ebp-0x80]를 보면 오버플로우를 발생시킬 버퍼는 ebp-0x80에 위치함을 알 수 있다. 스택 프레임의 구조를 떠올려보자. ebp에는 SFP가 저장되므로 ebp+0x4(공격 대상 컴퓨터는 32bit이므로 포인터 크기는 4바이트이기 때문이다.)에 return address가 저장될 것임을 알 수 있다. 따라서 0x80+0x4까지 더미 값으로 채워준 후 나머지를 셸코드로 채워주면 된다. 이를 바탕으로 exploit script를 작성해보자.




